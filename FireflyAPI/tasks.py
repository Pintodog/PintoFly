import json
import requests
from FireflyAPI import task_events
from FireflyAPI import files
from FireflyAPI import exceptions
from FireflyAPI.authentication import *


class TaskInterfaceFilter:
    """
    The TaskInterfaceFilter is needed in order to filter the homework tasks from the TaskInterface.getTasks() method
    Args:
        status (str): Either "Todo", "DoneOrArchived" or "AllIncludingArchived".
        read (bool, optional): Either True, False or None (meaning Read, Unread or All).
        sorting (list, optional): (sorting, sort_desc) where sorting is either "DueDate" or "SetDate" and order is either True or False.
        results (int, optional): Number of tasks to retrieve.
    """

    def __init__(self, status, read=None, sorting=("DueDate", True), results=20):
        self.status = status
        self.read = read
        self.results = results
        self.sorting = sorting
        self.__update_filter()

    def __update_filter(self):
        read_mapping = {None: "All", True: "OnlyRead", False: "OnlyUnread"}
        sort_order_mapping = {True: "Descending", False: "Ascending"}
        pages = (self.results - 1) // 50
        self.filters = []
        for page in range(0, pages + 1):
            self.filters.append({
                "ownerType": "OnlySetters",
                "page": page,
                "pageSize": min((self.results - 50 * page), 50),
                "archiveStatus": "All",
                "completionStatus": self.status,
                "readStatus": read_mapping[self.read],
                "markingStatus": "All",
                "sortingCriteria": [{
                    "column": self.sorting[0],
                    "order": sort_order_mapping[self.sorting[1]]
                }]})

class TaskInterface(DiscretelyAuthenticatedObject):
    """
    The TaskInterface class is used to get a list of tasks based on factors such as completion, read status etc.
    If you want to listen for task events, such as when a task is graded, use the ActiveTaskInterface class instead.
    This object can either be created via the AuthenticatedUser class or created by passing the auth_blob value upon creation.
    Args:
        auth_blob (str): This is generated by the UserIntegration class, and is used to authenticate as a user.
    """

    def get_tasks(self, task_filter=TaskInterfaceFilter("Todo")):
        """
        Args:
            task_filter (TaskInterfaceFilter, optional): The filter to use for getting the tasks. Returns tasks that are not done by default.
        Returns:
            array [Task Object]: An array of tasks that match the criteria of the filter specified.
        """
        all_tasks = []
        for page_filter in task_filter.filters:
            params = {"ffauth_device_id": self._DiscretelyAuthenticatedObject__device_id,
                      "ffauth_secret": self._DiscretelyAuthenticatedObject__device_token}
            response = requests.post(
                self._DiscretelyAuthenticatedObject__portal + "/api/v2/taskListing/view/student/tasks/all/filterBy",
                params=params, json=page_filter)
            tasks_data = json.loads(response.text)["items"]
            task_ids = []
            for task_data in tasks_data:
                task_ids.append(int(task_data["id"]))
            all_tasks += self.__get_tasks_from_ids(task_ids)
            # Break if no more tasks are left to download.
            if json.loads(response.text)["aggregateOffsets"]["toFfIndex"] < 50:
                break
        return all_tasks

    def __get_tasks_from_ids(self, ids):
        params = {"ffauth_device_id": self._DiscretelyAuthenticatedObject__device_id,
                  "ffauth_secret": self._DiscretelyAuthenticatedObject__device_token}
        json_data = {"ids": ids}
        response = requests.post(self._DiscretelyAuthenticatedObject__portal + "/api/v2/apps/tasks/byIds",
                                 params=params, data=json_data)
        tasks_data = json.loads(response.text)
        tasks = []
        for task_data in tasks_data:
            tasks.append(Task(self._DiscretelyAuthenticatedObject__auth_blob, task_data))
        return tasks


class ActiveTaskInterface(TaskInterface):
    """
    TODO: This class has not been programmed yet, but will be available soon.
    """
    def __init__(self, auth_blob):
        DiscretelyAuthenticatedObject.__init__(self, auth_blob)
        raise exceptions.UnimplementedError("You've found a feature that has not been implemented yet."
                                            "You can follow this repository on Github to be notified when this class is added.")


class Task(DiscretelyAuthenticatedObject):
    """
    The Task object contains information about a particular task.
    It can be generated by either the TaskInterface object or ActiveTaskInterface object.
    More information about the task is stored in the EventStore of the task.
    Args:
        auth_blob (str): This is generated by the UserIntegration class, and is used to authenticate as a user.
        task_data (dict Object): Lesson data in a dictionary format.
    Attributes:
        event_store (TaskEventStore Object): The collection of events related to the task.
        id (int): The internal ID of the task.
        title (str): The title of the task.
        set_date (datetime Object): The time and date on which the task was set.
        due_date (datetime Object): The time and date on which the task is due. Is None if no due date.
        personal_task (bool): Whether the task is a personal task or not.
        description (str): The description for the task (in HTML format).
        description_url (str): The full URL of the task description.
        contains_questions (bool): Whether the task contains questions or not.
        archived (bool): Whether the task is archived.
        file_submission_required (bool): Whether a file needs to be submitted to mark the task as done.
        max_mark (float): The maximum mark for the task. Is None if no maximum mark.
        set_by (str): The name of the teacher who set the task.
        classes (array [str]): The names of the classes to whom the task has been set to.
        file_attachments (array [File object]): A list of files for the assignment.

    """

    def __init__(self, auth_blob, task_data):
        DiscretelyAuthenticatedObject.__init__(self, auth_blob)
        self.__load_task_details(task_data)

    def __load_task_details(self, task_data):
        self.event_store = task_events.TaskEventStore(task_data["recipientsResponses"][0]["responses"],
                                                      self._DiscretelyAuthenticatedObject__guid)
        self.id = int(task_data["id"])
        self.title = task_data["title"]
        self.set_date = utils.firefly_timestamp_to_date_time(task_data["setDate"])
        # Due date could be missing if not specified
        try:
            self.due_date = utils.firefly_timestamp_to_date_time(task_data["dueDate"])
        except ValueError:
            self.due_date = None
        self.personal_task = (task_data["taskType"] == "PersonalTask")
        self.description = ""
        self.description_url = self._DiscretelyAuthenticatedObject__portal + "/" + task_data["descriptionPageUrl"]
        self.contains_questions = False
        if task_data["descriptionDetails"] is not None:
            self.contains_questions = task_data["descriptionDetails"]["containsQuestions"]
            self.description = task_data["descriptionDetails"]["htmlContent"]
        self.archived = task_data["archived"]
        self.file_submission_required = task_data["fileSubmissionRequired"]
        self.max_mark = task_data["totalMarkOutOf"]
        self.set_by = task_data["setter"]["name"]
        self.classes = []
        for addressee in task_data["addressees"]:
            self.classes.append(addressee["principal"]["name"])
        self.__assessmentDetailsId = task_data["assessmentDetailsId"]
        self.file_attachments = []
        if task_data["fileAttachments"] is not None:
            for file in task_data["fileAttachments"]:
                self.file_attachments.append(files.File(file))

    def can_mark_as_done(self):
        """
        Checks if the task can be marked as done.
        Returns:
            bool: True if task can be marked as done, False if not.
        """
        if (not self.event_store.done) and\
                ((not self.file_submission_required) or self.event_store.has_file_submission) and\
                (not self.contains_questions):
            return True
        return False

    def can_mark_as_undone(self):
        """
        Checks if the task can be marked as undone.
        Returns:
            bool: True if task can be marked as undone, False if not.
        """
        if (not self.archived) and self.event_store.done:
            return True
        return False

    def __set_completion_status(self, done):
        completion_mapping = {True: "mark-as-done", False: "mark-as-undone"}
        params = {"ffauth_device_id": self._DiscretelyAuthenticatedObject__device_id,
                  "ffauth_secret": self._DiscretelyAuthenticatedObject__device_token}
        data = {"data": str({"event": {"type": completion_mapping[done], "assessment_details_id": self.__assessmentDetailsId},
                             "recipient": {"guid": self._DiscretelyAuthenticatedObject__guid, "type": "user"}})}
        response = requests.post(
            self._DiscretelyAuthenticatedObject__portal + "/_api/1.0/tasks/" + str(self.id) + "/responses",
            params=params, data=data)
        if response.status_code != 200:
            return False
        return True
    def mark_as_read(self):
        """
        Marks a task as read.
        """
        params = {"ffauth_device_id": self._DiscretelyAuthenticatedObject__device_id,
                  "ffauth_secret": self._DiscretelyAuthenticatedObject__device_token}
        data = {"data": str({"recipient": {"guid": self._DiscretelyAuthenticatedObject__guid, "type": "user"}})}
        requests.post(
            self._DiscretelyAuthenticatedObject__portal + "/_api/1.0/tasks/" + str(self.id) + "/mark_as_read",
            params=params, data=data)
    def add_comment(self, message):
        """
        Adds a comment to a task.
        Args:
            message (str): The comment message.
        """
        params = {"ffauth_device_id": self._DiscretelyAuthenticatedObject__device_id,
                  "ffauth_secret": self._DiscretelyAuthenticatedObject__device_token}
        data = {"data": str({"event": {"type": "comment", "message": message, "assessment_details_id": self.__assessmentDetailsId},
                             "recipient": {"guid": self._DiscretelyAuthenticatedObject__guid, "type": "user"}})}
        requests.post(
            self._DiscretelyAuthenticatedObject__portal + "/_api/1.0/tasks/" + str(self.id) + "/responses",
            params=params, data=data)

    def mark_as_done(self):
        """
        Marks a task as done, if that is possible.
        Returns:
            bool: True if successful.
        """
        if self.can_mark_as_done():
            return self.__set_completion_status(True)
        return False

    def mark_as_undone(self):
        """
        Marks a task as undone, if that is possible.
        Returns:
            bool: True if successful.
        """
        if self.can_mark_as_undone():
            return self.__set_completion_status(False)
        return False
