import json
import requests
from FireflyAPI import task_events
from FireflyAPI import files
from FireflyAPI.authentication import *


class TaskInterfaceFilter:
    """
    The TaskInterfaceFilter is needed in order to filter the homework tasks from the TaskInterface.getTasks() method
    Args:
        todo (str): Either "Todo", "DoneOrArchived" or "AllIncludingArchived".
        read (bool, optional): Either True, False or None (meaning Read, Unread or All).
        sorting (list, optional): (sorting, sort_desc) where sorting is either "DueDate" or "SetDate" and order is either True or False.
        results (int, optional): Number of tasks to retrieve.
    """

    def __init__(self, todo, read=None, sorting=("DueDate", True), results=20):
        self.todo = todo
        self.read = read
        self.results = results
        self.sorting = sorting
        self.__update_filter()

    def __update_filter(self):
        read_mapping = {None: "All", True: "OnlyRead", False: "OnlyUnread"}
        sort_order_mapping = {True: "Descending", False: "Ascending"}
        self.filter = {
            "ownerType": "OnlySetters",
            "page": 0,
            "pageSize": self.results,
            "archiveStatus": "All",
            "completionStatus": self.todo,
            "readStatus": read_mapping[self.read],
            "markingStatus": "All",
            "sortingCriteria": [{
                "column": self.sorting[0],
                "order": sort_order_mapping[self.sorting[1]]
            }]
        }


class TaskInterface(DiscretelyAuthenticatedObject):
    """
    The TaskInterface class is used to get a list of tasks based on factors such as completion, read status etc.
    If you need to get the task description or frequently get tasks, please use the ActiveHomeworkInterface class instead.
    This object can either be created via the AuthenticatedUser class or created by passing the auth_blob value upon creation.
    Args:
        auth_blob (str): This is generated by the UserIntegration class, and is used to authenticate as a user.
    """

    def get_tasks(self, task_filter=TaskInterfaceFilter("Todo")):
        # These are needed for security reasons (to prevent click hijacking)
        headers = {"Host": str(self._DiscretelyAuthenticatedObject__portal).split("/")[-1],
                   "Origin": self._DiscretelyAuthenticatedObject__portal,
                   "Referer": self._DiscretelyAuthenticatedObject__portal + "/set-tasks"}
        # Get session token for authentication
        session = utils.get_session_token(self._DiscretelyAuthenticatedObject__auth_blob)
        cookies = {"ASP.NET_SessionId": session}
        response = requests.post(
            self._DiscretelyAuthenticatedObject__portal + "/api/v2/taskListing/view/student/tasks/all/filterBy",
            cookies=cookies, json=task_filter.filter, headers=headers)
        tasks_data = json.loads(response.text)["items"]
        task_ids = []
        for task_data in tasks_data:
            task_ids.append(int(task_data["id"]))
        return self.__get_tasks_from_ids(task_ids)

    def __get_tasks_from_ids(self, ids):
        params = {"ffauth_device_id": self._DiscretelyAuthenticatedObject__device_id,
                  "ffauth_secret": self._DiscretelyAuthenticatedObject__device_token}
        json_data = {"ids": ids}
        response = requests.post(self._DiscretelyAuthenticatedObject__portal + "/api/v2/apps/tasks/byIds",
                                 params=params, data=json_data)
        tasks_data = json.loads(response.text)
        tasks = []
        for task_data in tasks_data:
            tasks.append(Task(self._DiscretelyAuthenticatedObject__auth_blob, task_data))
        return tasks


class Task(DiscretelyAuthenticatedObject):
    """
    The Task object contains information about a particular task.
    It can be generated by either the TaskInterface object or ActiveTaskInterface object.
    More information about the task is stored in the EventStore of the task.
    Args:
        auth_blob (str): This is generated by the UserIntegration class, and is used to authenticate as a user.
        task_data (dict Object): Lesson data in a dictionary format.
    Attributes:
        event_store (TaskEventStore Object): The collection of events related to the task.
        id (int): The internal ID of the task.
        title (str): The title of the task.
        set_date (datetime Object): The time and date on which the task was set.
        due_date (datetime Object): The time and date on which the task is due. Is None if no due date.
        personal_task (bool): Whether the task is a personal task or not.
        description (str): The description for the task (in HTML format).
        description_url (str): The full URL of the task description.
        contains_questions (bool): Whether the task contains questions or not.
        archived (bool): Whether the task is archived.
        file_submission_required (bool): Whether a file needs to be submitted to mark the task as done.
        max_mark (float): The maximum mark for the task. Is None if no maximum mark.
        set_by (str): The name of the teacher who set the task.
        classes (array [str]): The names of the classes to whom the task has been set to.
        file_attachments (array [File object]): A list of files for the assignment.

    """

    def __init__(self, auth_blob, task_data):
        DiscretelyAuthenticatedObject.__init__(self, auth_blob)
        self.__load_task_details(task_data)

    def __load_task_details(self, task_data):
        self.event_store = task_events.TaskEventStore(task_data["recipientsResponses"][0]["responses"],
                                                      self._DiscretelyAuthenticatedObject__guid)
        self.id = int(task_data["id"])
        self.title = task_data["title"]
        self.set_date = utils.firefly_timestamp_to_date_time(task_data["setDate"])
        # Due date could be missing if not specified
        try:
            self.due_date = utils.firefly_timestamp_to_date_time(task_data["dueDate"])
        except ValueError:
            self.due_date = None
        self.personal_task = (task_data["taskType"] == "PersonalTask")
        self.description = ""
        self.description_url = self._DiscretelyAuthenticatedObject__portal + "/" + task_data["descriptionPageUrl"]
        self.contains_questions = False
        if task_data["descriptionDetails"] is not None:
            self.contains_questions = task_data["descriptionDetails"]["containsQuestions"]
            self.description = task_data["descriptionDetails"]["htmlContent"]
        self.archived = task_data["archived"]
        self.file_submission_required = task_data["fileSubmissionRequired"]
        self.max_mark = task_data["totalMarkOutOf"]
        self.set_by = task_data["setter"]["name"]
        self.classes = []
        for addressee in task_data["addressees"]:
            self.classes.append(addressee["principal"]["name"])
        self.__assessmentDetailsId = task_data["assessmentDetailsId"]
        self.file_attachments = []
        if task_data["fileAttachments"] is not None:
            for file in task_data["fileAttachments"]:
                self.file_attachments.append(files.File(file))

    def can_mark_as_done(self):
        """
        Checks if the task can be marked as done.
        Returns:
            bool: True if task can be marked as done, False if not.
        """
        if (not self.event_store.done) and\
                ((not self.file_submission_required) or self.event_store.has_file_submission) and\
                (not self.contains_questions):
            return True
        return False

    def can_mark_as_undone(self):
        """
        Checks if the task can be marked as undone.
        Returns:
            bool: True if task can be marked as undone, False if not.
        """
        if (not self.archived) and self.event_store.done:
            return True
        return False

    def __set_completion_status(self, done):
        completion_mapping = {True: "mark-as-done", False: "mark-as-undone"}
        params = {"ffauth_device_id": self._DiscretelyAuthenticatedObject__device_id,
                  "ffauth_secret": self._DiscretelyAuthenticatedObject__device_token}
        data = {"data": str({"event": {"type": completion_mapping[done], "assessment_details_id": 0},
                             "recipient": {"guid": self._DiscretelyAuthenticatedObject__guid, "type": "user"}})}
        response = requests.post(
            self._DiscretelyAuthenticatedObject__portal + "/_api/1.0/tasks/" + str(self.id) + "/responses",
            params=params, data=data)
        if response.status_code != 200:
            return False
        return True

    def mark_as_done(self):
        """
        Marks a task as done, if that is possible.
        Returns:
            bool: True if successful.
        """
        if self.can_mark_as_done():
            return self.__set_completion_status(True)
        return False

    def mark_as_undone(self):
        """
        Marks a task as undone, if that is possible.
        Returns:
            bool: True if successful.
        """
        if self.can_mark_as_undone():
            return self.__set_completion_status(False)
        return False
