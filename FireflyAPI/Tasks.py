import json, requests, datetime
from FireflyAPI import Utils


class TaskInterfaceFilter:
    '''
    The TaskInterfaceFilter is needed in order to filter the homework tasks from the TaskInterface.getTasks() method
    Args:
        todo (str): Either "Todo", "DoneOrArchived" or "AllIncludingArchived".
        read (bool, optional): Either True, False or None (meaning Read, Unread or All).
        sorting (list, optional): (sorting, sort_desc) where sorting is either "DueDate" or "SetDate" and order is either True or False.
        results (int, optional): Number of tasks to retrieve.
    '''
    def __init__(self, todo, read = None, sorting=("DueDate", True), results=20):
        self.todo = todo
        self.read = read
        self.results = results
        self.sorting = sorting
        self.__updateFilter()
    def __updateFilter(self):
        read_mapping = {None:"All", True:"OnlyRead", False:"OnlyUnread"}
        sort_order_mapping = {True:"Descending",False:"Ascending"}
        self.filter = {
            "ownerType": "OnlySetters",
            "page": 0,
            "pageSize": self.results,
            "archiveStatus": "All",
            "completionStatus": self.todo,
            "readStatus": read_mapping[self.read],
            "markingStatus": "All",
            "sortingCriteria": [{
                "column": self.sorting[0],
                "order": sort_order_mapping[self.sorting[1]]
            }]
        }
class TaskInterface:
    '''
    The TaskInterface class is used to get a list of tasks based on factors such as completion, read status etc.
    If you need to get the task description or frequently get tasks, please use the ActiveHomeworkInterface class instead.
    This object can either be created via the AuthenticatedUser class or created by passing the auth_blob value upon creation.
    Args:
        auth_blob (str): This is generated by the UserIntegration class, and is used to authenticate as a user.
    '''
    def __init__(self, auth_blob):
        self.__auth_blob = auth_blob
        auth_data = Utils.unpackAuthBlob(auth_blob)
        self.__device_id = auth_data["device_id"]
        self.__device_token = auth_data["device_token"]
        self.__portal = auth_data["portal"]
        self.__guid = auth_data["guid"]
    def getTasks(self, filter = TaskInterfaceFilter("Todo")):
        # These are needed for security reasons (to prevent click hijacking)
        headers = {"Host": str(self.__portal).split("/")[-1],
                   "Origin": self.__portal,
                   "Referer": self.__portal + "/set-tasks"}
        # Get session token for authentication
        session = Utils.getSessionToken(self.__auth_blob)
        cookies = {"ASP.NET_SessionId": session}
        response = requests.post(self.__portal + "/api/v2/taskListing/view/student/tasks/all/filterBy",
                               cookies=cookies, json=filter.filter, headers=headers)
        tasks_data = json.loads(response.text)["items"]
        task_ids = []
        for task_data in tasks_data:
            task_ids.append(int(task_data["id"]))
        return self.__getTasksFromIds(task_ids)
    def __getTasksFromIds(self, ids):
        params = {"ffauth_device_id": self.__device_id,
                  "ffauth_secret": self.__device_token}
        json_data = {"ids":ids}
        response = requests.post(self.__portal + "/api/v2/apps/tasks/byIds", params=params, data=json_data)
        tasks_data = json.loads(response.text)
        print(response.text)
        return None
    def __proccessEvents(self, events, watermark = None):
        for event in events:
            TODO

class Task:
    def __init__(self, auth_blob, task_data):
        self.__auth_blob = auth_blob
        auth_data = Utils.unpackAuthBlob(auth_blob)
        self.__device_id = auth_data["device_id"]
        self.__device_token = auth_data["device_token"]
        self.__portal = auth_data["portal"]
        self.__guid = auth_data["guid"]
        # Unpack homework data
        self.__load_task_details(task_data)
    def __load_task_details(self, task_data):
        self.id = int(task_data["id"])
        self.title = task_data["title"]
        self.set_date = Utils.fireflyTimestampToDateTime(task_data["setDate"])
        # Due date could be missing if not specified
        try:
            self.due_date = Utils.fireflyTimestampToDateTime(task_data["dueDate"])
        except:
            self.due_date = None
        self.personal_task = (task_data["taskType"] == "PersonalTask")
        self.done = task_data["isDone"]
        self.resubmission_required = task_data["isResubmissionRequired"]
        self.archived = task_data["archived"]
        self.read = task_data["isUnread"]
        self.file_submission_required = task_data["fileSubmissionRequired"]
        self.file_submitted = task_data["hasFileSubmission"]
        self.contains_questions = task_data["descriptionContainsQuestions"]
        self.set_by = task_data["setter"]["name"]
        self.set_to = []
        for addressee in task_data["addressees"]:
            self.set_to.append(addressee["name"])
        self.marked = task_data["mark"]["isMarked"]
        if self.marked:
            self.grade = task_data["mark"]["grade"]
            self.mark = task_data["mark"]["mark"]
            self.max_mark = task_data["mark"]["markMax"]
            if self.mark and self.max_mark:
                self.percentage_mark = int((self.mark / self.max_mark) * 100)
            self.feedback_given = task_data["mark"]["hasFeedback"]

    def canMarkAsDone(self):
        '''
        Checks if the task can be marked as done.
        Returns:
            bool: True if task can be marked as done, False if not.
        '''
        if (not self.done) and ((not self.file_submission_required) or self.file_submitted) and (not self.contains_questions):
            return True
        return False
    def canMarkAsUndone(self):
        '''
        Checks if the task can be marked as undone.
        Returns:
            bool: True if task can be marked as undone, False if not.
        '''
        if (not self.archived) and self.done and (not self.marked):
            return True
        return False
    def __setCompletionStatus(self, done):
        completion_mapping = {True:"mark-as-done", False:"mark-as-undone"}
        params = {"ffauth_device_id": self.__device_id,
                  "ffauth_secret": self.__device_token}
        data = {"data": str({"event":{"type":completion_mapping[done],"assessment_details_id":0},"recipient":{"guid":self.__guid,"type":"user"}})}
        response = requests.post(self.__portal + "/_api/1.0/tasks/"+str(self.id)+"/responses", params=params, data=data)
        if response.status_code != 200:
            return False
        return True
    def markAsDone(self):
        '''
        Marks a task as done, if that is possible.
        Returns:
            bool: True if successful.
        '''
        if self.canMarkAsDone():
            self.__setCompletionStatus(True)
            return True
        self.__setCompletionStatus(True)
        return False
    def markAsUndone(self):
        '''
        Marks a task as undone, if that is possible.
        Returns:
            bool: True if successful.
        '''
        if self.canMarkAsUndone():
            self.__setCompletionStatus(self, False)
            return True
        return False




